{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Vigiliant Crypto Snatch is a little program that observes the current market price for your choice of currency pairs, looks for drastic reductions (dips) and then places buy orders. The basic idea is to use the Dollar Cost Average effect in a bit more clever way. By buying in fixed time intervals for a certain amount of fiat currency, one can profit from a sideways moving market with fluctuations. We can try to improve on this by also actively looking for reductions in the price to buy more cryptocurrency for the same fiat amount. First you need to install the software, then configure it. Test the program using the instructions for running , then choose a deployment strategy that suits your needs. You can find the source code on GitHub . Download statistics via PyPI Stats . In case you wonder about the name: Dips means that the price dives. Submarines dive. The HMS Vigilant is a submarine of the British Navy. But also vigilance means to observe.","title":"Welcome"},{"location":"#welcome","text":"Vigiliant Crypto Snatch is a little program that observes the current market price for your choice of currency pairs, looks for drastic reductions (dips) and then places buy orders. The basic idea is to use the Dollar Cost Average effect in a bit more clever way. By buying in fixed time intervals for a certain amount of fiat currency, one can profit from a sideways moving market with fluctuations. We can try to improve on this by also actively looking for reductions in the price to buy more cryptocurrency for the same fiat amount. First you need to install the software, then configure it. Test the program using the instructions for running , then choose a deployment strategy that suits your needs. You can find the source code on GitHub . Download statistics via PyPI Stats . In case you wonder about the name: Dips means that the price dives. Submarines dive. The HMS Vigilant is a submarine of the British Navy. But also vigilance means to observe.","title":"Welcome"},{"location":"deployment/","text":"Deployment Using the other pages, you should have already configured the program and tried to use it. It should log into the marketplace, report your balance and load the triggers. Then you can start it and have it run, but you likely want a proper deployment. Most users seem to have a Raspberry Pi, which is an affordable miniature server. It is perfectly suited to run this little Python program. You can also run it on a larger server, if you want. We will introduce a couple ways that you can deploy this program. Screen session If you log into your Linux server via SSH and start a program, it will run on the server. But when you disconnect, the program will be shut shown. This is not what we want, we want to have the service running the whole time. Therefore a simple SSH connection is not appropriate. Fortunately there are terminal multiplexers , namely screen and tmux . For our purposes both are just perfectly fine. The idea is that you have a persistent terminal on the server, and you just attach to see it, and detach from viewing it. It is still there, even if you don't see it. For that start a new screen session, and perhaps already give it a name (we use vigilant here, but you are free to choose): $ screen -S vigilant Not much will change, you will get a fresh screen. Then start the program as documented in the usage page. It should start up. Then you can Ctrl + A , then D . This will detach the session. Use screen -ls to see a list of all sessions that are open. This can look like this: $ screen -ls There is a screen on: 445439.vigilant (Detached) 1 Socket in /run/screen/S-mu. Now you can logout via SSH, and the program will still run. Later you can log back in and use screen -r vigilant to reattach the session and control it or look at the log output. Team Viewer You might have set up your Raspberry Pi with a graphical user interface and a running session. In that case you log into that session using Team Viewer or any other remote administration tool. Just open a terminal window and start the program. It will keep running when you disconnect from Team Viewer. Systemd unit A very modern approach for continuous running is to use systemd. That is the program which starts all the other programs on a modern Linux system. It needs to have a definition of the service. It is a text file which looks like this: [Unit] Description = Vigilant Crypto Snatch Service (watch) StartLimitIntervalSec = 500 StartLimitBurst = 5 After = network.target [Service] User = USERNAME ExecStart = /usr/local/bin/vigilant-crypto-snatch watch --marketplace kraken --keepalive Restart = on-failure RestartSec = 5s [Install] WantedBy = multi-user.target Create a text file at /etc/systemd/system/vigilant-crypto-snatch.service and put that content into it, making these changes: Be sure to replace the placeholder USERNAME with the one where you have put the config. On a Raspberry Pi that is usually just the username pi . You can find out like this: $ echo $USER mu You also need to change the path, which you can find out by executing type vigilant-crypto-snatch on the command line. The command line flags might not be the ones you want, perhaps you want a different market place. Once you have that unit in place, you can query systemd to show you this unit: $ sudo systemctl status vigilant-crypto-snatch \u25cb vigilant-crypto-snatch.service - Vigilant Crypto Snatch Service (watch) Loaded: loaded (/etc/systemd/system/vigilant-crypto-snatch.service; disabled; vendor preset: disabled) Active: inactive (dead) If you want to have this unit started on system startup, you need to enable it with sudo systemctl enable vigilant-crypto-snatch . To start the unit, you use sudo systemctl start vigilant-crypto-snatch . Using the above status command you can check whether it has started or crashed and also get the latest error messages.","title":"Deployment"},{"location":"deployment/#deployment","text":"Using the other pages, you should have already configured the program and tried to use it. It should log into the marketplace, report your balance and load the triggers. Then you can start it and have it run, but you likely want a proper deployment. Most users seem to have a Raspberry Pi, which is an affordable miniature server. It is perfectly suited to run this little Python program. You can also run it on a larger server, if you want. We will introduce a couple ways that you can deploy this program.","title":"Deployment"},{"location":"deployment/#screen-session","text":"If you log into your Linux server via SSH and start a program, it will run on the server. But when you disconnect, the program will be shut shown. This is not what we want, we want to have the service running the whole time. Therefore a simple SSH connection is not appropriate. Fortunately there are terminal multiplexers , namely screen and tmux . For our purposes both are just perfectly fine. The idea is that you have a persistent terminal on the server, and you just attach to see it, and detach from viewing it. It is still there, even if you don't see it. For that start a new screen session, and perhaps already give it a name (we use vigilant here, but you are free to choose): $ screen -S vigilant Not much will change, you will get a fresh screen. Then start the program as documented in the usage page. It should start up. Then you can Ctrl + A , then D . This will detach the session. Use screen -ls to see a list of all sessions that are open. This can look like this: $ screen -ls There is a screen on: 445439.vigilant (Detached) 1 Socket in /run/screen/S-mu. Now you can logout via SSH, and the program will still run. Later you can log back in and use screen -r vigilant to reattach the session and control it or look at the log output.","title":"Screen session"},{"location":"deployment/#team-viewer","text":"You might have set up your Raspberry Pi with a graphical user interface and a running session. In that case you log into that session using Team Viewer or any other remote administration tool. Just open a terminal window and start the program. It will keep running when you disconnect from Team Viewer.","title":"Team Viewer"},{"location":"deployment/#systemd-unit","text":"A very modern approach for continuous running is to use systemd. That is the program which starts all the other programs on a modern Linux system. It needs to have a definition of the service. It is a text file which looks like this: [Unit] Description = Vigilant Crypto Snatch Service (watch) StartLimitIntervalSec = 500 StartLimitBurst = 5 After = network.target [Service] User = USERNAME ExecStart = /usr/local/bin/vigilant-crypto-snatch watch --marketplace kraken --keepalive Restart = on-failure RestartSec = 5s [Install] WantedBy = multi-user.target Create a text file at /etc/systemd/system/vigilant-crypto-snatch.service and put that content into it, making these changes: Be sure to replace the placeholder USERNAME with the one where you have put the config. On a Raspberry Pi that is usually just the username pi . You can find out like this: $ echo $USER mu You also need to change the path, which you can find out by executing type vigilant-crypto-snatch on the command line. The command line flags might not be the ones you want, perhaps you want a different market place. Once you have that unit in place, you can query systemd to show you this unit: $ sudo systemctl status vigilant-crypto-snatch \u25cb vigilant-crypto-snatch.service - Vigilant Crypto Snatch Service (watch) Loaded: loaded (/etc/systemd/system/vigilant-crypto-snatch.service; disabled; vendor preset: disabled) Active: inactive (dead) If you want to have this unit started on system startup, you need to enable it with sudo systemctl enable vigilant-crypto-snatch . To start the unit, you use sudo systemctl start vigilant-crypto-snatch . Using the above status command you can check whether it has started or crashed and also get the latest error messages.","title":"Systemd unit"},{"location":"developing/","text":"Developing If you want to contribute, that's awesome! It is best if you get in touch first, then we can discuss the best way to add your idea. We try to develop this in a Clean Code way, with the least amount of coupling. We also follow the Hypermodern Python series for project layout and choice of tooling. Development setup This project is written in Python. It uses Poetry to manage the project and its dependencies. Once you have obtained the source code via git clone , you can install the project into a virtual environment using poetry install . This will install all the dependencies and the package. You can of course use any Python development environment that you want. Martin can recommend PyCharm Community Edition . Make sure to install the \u201cPoetry\u201d plugin to easily set up the virtual environment. In order to run in development mode, use Poetry: poetry run vigilant-crypto-snatch [ more command line arguments ] You can run the tests with pytest : poetry run pytest In order to determine test coverage, use this: poetry run coverage run --source = src -m pytest poetry run coverage html We use the pre-commit tool . So also run pre-commit install to set it up. This will take care of code formatting with Black , static type checking, unit test and test coverage on every commit. Updating the documentation The documentation is created with Material for MkDocs . Just edit the Markdown files in docs . To locally view the documentation, use this: poetry run mkdocs serve New release In order to create a new release, we use the make-release script. It requires the access credentials to GitHub and PyPI and Codecov, so only Martin can do that at this point.","title":"Developing"},{"location":"developing/#developing","text":"If you want to contribute, that's awesome! It is best if you get in touch first, then we can discuss the best way to add your idea. We try to develop this in a Clean Code way, with the least amount of coupling. We also follow the Hypermodern Python series for project layout and choice of tooling.","title":"Developing"},{"location":"developing/#development-setup","text":"This project is written in Python. It uses Poetry to manage the project and its dependencies. Once you have obtained the source code via git clone , you can install the project into a virtual environment using poetry install . This will install all the dependencies and the package. You can of course use any Python development environment that you want. Martin can recommend PyCharm Community Edition . Make sure to install the \u201cPoetry\u201d plugin to easily set up the virtual environment. In order to run in development mode, use Poetry: poetry run vigilant-crypto-snatch [ more command line arguments ] You can run the tests with pytest : poetry run pytest In order to determine test coverage, use this: poetry run coverage run --source = src -m pytest poetry run coverage html We use the pre-commit tool . So also run pre-commit install to set it up. This will take care of code formatting with Black , static type checking, unit test and test coverage on every commit.","title":"Development setup"},{"location":"developing/#updating-the-documentation","text":"The documentation is created with Material for MkDocs . Just edit the Markdown files in docs . To locally view the documentation, use this: poetry run mkdocs serve","title":"Updating the documentation"},{"location":"developing/#new-release","text":"In order to create a new release, we use the make-release script. It requires the access credentials to GitHub and PyPI and Codecov, so only Martin can do that at this point.","title":"New release"},{"location":"donation/","text":"Donation If this project has been useful for you, and you would like to give a gift as a contribution, we would be very grateful to receive it. We have a couple of options for you. PayPal You can send money via to Chris via PayPal . GitHub Sponsors You can go to our GitHub page and use the GitHub Sponsorship to donate some money. Bitcoin There is also the possibility to send Bitcoin. Chris has set up a donation page here: Donation via Tallycoin You can make an on-chain or Lightning donation.","title":"Donation"},{"location":"donation/#donation","text":"If this project has been useful for you, and you would like to give a gift as a contribution, we would be very grateful to receive it. We have a couple of options for you.","title":"Donation"},{"location":"donation/#paypal","text":"You can send money via to Chris via PayPal .","title":"PayPal"},{"location":"donation/#github-sponsors","text":"You can go to our GitHub page and use the GitHub Sponsorship to donate some money.","title":"GitHub Sponsors"},{"location":"donation/#bitcoin","text":"There is also the possibility to send Bitcoin. Chris has set up a donation page here: Donation via Tallycoin You can make an on-chain or Lightning donation.","title":"Bitcoin"},{"location":"license/","text":"License Copyright 2019, 2021 Dr. Martin Ueding, Christoph Hansen This project contains of two parts. The main library is MIT licensed, and the Qt GUI is GPL 3 licensed. The GUI uses code of the library, but not the other way around.","title":"License"},{"location":"license/#license","text":"Copyright 2019, 2021 Dr. Martin Ueding, Christoph Hansen This project contains of two parts. The main library is MIT licensed, and the Qt GUI is GPL 3 licensed. The GUI uses code of the library, but not the other way around.","title":"License"},{"location":"support/","text":"Support The documentation hopefully answers most common question. In case you find it lacking, have a problem or want to suggest a feature, you have a couple of options. Issue tracker For all sorts of issues and feature requests it is easiest if you just open a new ticket in the issue tracker on GitHub . This way they are structured and I can directly reply to you. Telegram group We also have a Telegram group where developers and users hang out, discuss the application, bugs and features.","title":"Support"},{"location":"support/#support","text":"The documentation hopefully answers most common question. In case you find it lacking, have a problem or want to suggest a feature, you have a couple of options.","title":"Support"},{"location":"support/#issue-tracker","text":"For all sorts of issues and feature requests it is easiest if you just open a new ticket in the issue tracker on GitHub . This way they are structured and I can directly reply to you.","title":"Issue tracker"},{"location":"support/#telegram-group","text":"We also have a Telegram group where developers and users hang out, discuss the application, bugs and features.","title":"Telegram group"},{"location":"changelog/version-2/","text":"Version 2 Version 2.0.0 Use logging library for colorful log messages. Add a nice documentation website. Add log messages via Telegram. Gracefully handle keyboard interrupt. Add --keepalive option again. Add automatic database cleaning. Version 2.1.0 Add regular Telegram messages to let user know that the program is still running.","title":"Version 2"},{"location":"changelog/version-2/#version-2","text":"","title":"Version 2"},{"location":"changelog/version-2/#version-200","text":"Use logging library for colorful log messages. Add a nice documentation website. Add log messages via Telegram. Gracefully handle keyboard interrupt. Add --keepalive option again. Add automatic database cleaning.","title":"Version 2.0.0"},{"location":"changelog/version-2/#version-210","text":"Add regular Telegram messages to let user know that the program is still running.","title":"Version 2.1.0"},{"location":"changelog/version-3/","text":"Version 3 Version 3.0.0 Add Windows support. Move configuration file to a new location. Old configuration files are automatically moved. Read Telegram chat ID from configuration file if available. This way you only have to send it a message once. Import modules only when needed to speed up start-up. More documentation. Add donation page. Use the Black code formatter. Start with Pytest unittests. Implement command line interface with Click. Version 3.0.1 Perform evaluation with actual trigger implementations. Version 3.0.2 Buxfixes. Version 3.0.3 Change command line argument parser back to argparse . Catch another connection exception. Catch connection errors in Telegram logger such that there are no endless recursive log messages which crash the program. Fix cool-off for 06:00 checkin. Fix some test code. Version 3.1.0 Add evaluation interface powered by Streamlit. More documentation in general. Add installation instructions for the evaluation feature. Version 3.2.0 Add a summary table for the drop evaluation interface. Version 3.3.0 Emit the exchange rate in the buy notification. Add more documentation. Fix axes label in plot. Allow evaluation of multiple triggers at the same time. Add progress bars to the Streamlit interface. Version 3.4.0 Reflect change from XBT to BTC coding on Kraken. Query balances on the marketplace at startup and after each trade. A notification is send such that you always know how much fiat money is left to trade. In the trigger evaluation, triggers are moved to multiple rows if there are more than three of them. Allow trigger evaluation on a chosen subrange of dates. Present trigger evaluation summary as a table. Make plots interactive. Version 3.5.0 Add --one-shot to the watch subcommand to only run the watch loop once. Update documentation and state paths to the configuration file on various platforms. Add fiat_percentage: true option to create drop triggers that use a percentage of the available fiat balance instead of a fixed volume. Version 3.5.1 Fix drop trigger with percentage such that volume_fiat is actually a percentage and not a ratio (between 0 and 1).","title":"Version 3"},{"location":"changelog/version-3/#version-3","text":"","title":"Version 3"},{"location":"changelog/version-3/#version-300","text":"Add Windows support. Move configuration file to a new location. Old configuration files are automatically moved. Read Telegram chat ID from configuration file if available. This way you only have to send it a message once. Import modules only when needed to speed up start-up. More documentation. Add donation page. Use the Black code formatter. Start with Pytest unittests. Implement command line interface with Click.","title":"Version 3.0.0"},{"location":"changelog/version-3/#version-301","text":"Perform evaluation with actual trigger implementations.","title":"Version 3.0.1"},{"location":"changelog/version-3/#version-302","text":"Buxfixes.","title":"Version 3.0.2"},{"location":"changelog/version-3/#version-303","text":"Change command line argument parser back to argparse . Catch another connection exception. Catch connection errors in Telegram logger such that there are no endless recursive log messages which crash the program. Fix cool-off for 06:00 checkin. Fix some test code.","title":"Version 3.0.3"},{"location":"changelog/version-3/#version-310","text":"Add evaluation interface powered by Streamlit. More documentation in general. Add installation instructions for the evaluation feature.","title":"Version 3.1.0"},{"location":"changelog/version-3/#version-320","text":"Add a summary table for the drop evaluation interface.","title":"Version 3.2.0"},{"location":"changelog/version-3/#version-330","text":"Emit the exchange rate in the buy notification. Add more documentation. Fix axes label in plot. Allow evaluation of multiple triggers at the same time. Add progress bars to the Streamlit interface.","title":"Version 3.3.0"},{"location":"changelog/version-3/#version-340","text":"Reflect change from XBT to BTC coding on Kraken. Query balances on the marketplace at startup and after each trade. A notification is send such that you always know how much fiat money is left to trade. In the trigger evaluation, triggers are moved to multiple rows if there are more than three of them. Allow trigger evaluation on a chosen subrange of dates. Present trigger evaluation summary as a table. Make plots interactive.","title":"Version 3.4.0"},{"location":"changelog/version-3/#version-350","text":"Add --one-shot to the watch subcommand to only run the watch loop once. Update documentation and state paths to the configuration file on various platforms. Add fiat_percentage: true option to create drop triggers that use a percentage of the available fiat balance instead of a fixed volume.","title":"Version 3.5.0"},{"location":"changelog/version-3/#version-351","text":"Fix drop trigger with percentage such that volume_fiat is actually a percentage and not a ratio (between 0 and 1).","title":"Version 3.5.1"},{"location":"changelog/version-4/","text":"Version 4 Version 4.0.0 The trigger specification is significantly changed. Consult the documentation to learn about the new format. I'm sorry for breaking your configuration, but I didn't want to provide a migration and rather deliver more new features. Version 4.1.0 Use krakenex instead of clikraken to communicate with Kraken. The old implementation is deprecated but retained with --marketplace clikraken . Add automatic withdrawal for currency when the amount exceeds a certain threshold determined by the fee. See the configuration of the Kraken marketplace for details. Version 4.2.0 \ud83e\uddea New features: Triggers can be given names in the evaluation interface. For the Kraken marketplace you can now specify whether the fees should be applied to base or quote currency. Attach a stack trace of exceptions to the Telegram message. In the drop survey evaluation one now also has a time range slider such that one can get a feeling for the drops. Some are one-time events, and others are regular patterns. \ud83d\udd27 Improvements: The reported balance at startup will only contain currencies which are used in triggers. This will remove some leftover shitcoins that people might left in their account. After a trade only the balances for that currency pair will be reported to give a cleaner report. The legend in the trigger simulation plot is shown below the plot to allow for longer trigger names without having them cropped. Triggers with failures used to get deactivated completely. Once no more triggers were active, the program was shut down. Failures stemming from insufficient funds are easily recovered from by transferring more money to the marketplace. The bot would have to be restarted afterwards. In order to make this unnecessary, failed triggers are just silenced for 12 hours. Another attempt is made automatically afterwards. This keeps the number of messages relatively low. \ud83e\udeb2 Bug fixes: Historical API was broken, it now retrieves data again. Specifying a lower-case fiat currency and using the percentage based fiat volume strategy led to an error. This is now fixed and the fiat currency is again case-insensitive. Make sure that errors from the Telegram API are reported and not ignored. Do not use Markdown with Telegram as parsing errors prevent messages from being sent. Plain text is not as pretty, but better have it reliable no matter which names the Triggers have. Errors from the historical price source have been silently ignored. They now issue a warning. \u2699\ufe0f Implementation details: clikraken has been retired and we now use krakenex in version 2. This version is in conflice with clikraken , which needs krakenex version 1. When you upgrade, you might see this message: ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts. clikraken 0.8.3.2 requires krakenex<1.0,>=0.1, but you have krakenex 2.1.0 which is incompatible. To resolve this, run pip uninstall clikraken or sudo pip uninstall clikraken , depending on whether you have installed it with --user in the past. Send Telegram messages via POST (and not GET). Automatically move the SQLite database into the appropriate user data directory on Windows on macOS, no change on Linux. Version 4.2.1 When a trigger was disabled after three consecutive failures, a message stating that would be shown every time the trigger was processed. In this way the user got the same amount of messages. This message is now removed. The initial errors speak for themselves, there is no need to have this additional message. Version 4.2.2 Another warning message would use a constant that was moved to another place in the meantime. The program crashed when the message was going to be emitted. It has been removed now. Version 4.2.3 Log output is also put into the Linux system log. In this way one can do post-mortem debugging. Crashes have been reported when the Telegram message was longer than their limit of 4096 characters. Messages are now chunked to prevent this from happening. Telegram messages are no longer directly send but stored in a send-queue. This way connection outages do not yield lost messages but rather just delay sending. Use a proper form instead of the plain button in Streamlit. Version 4.2.4 Also handle ReadTimeout errors that can happen when the API doesn't answer before the connection breaks. These have been ignored previously, but now the error message is a bit cleaner. Version 4.3.0 New features: Add a start attributes to triggers. Add --dry-run option to watch command such that it can be tested without spending money. Allow specifying delay and cooldown not only in minutes as delay_minutes and cooldown_minutes , but also as delay_hours , delay_days , cooldown_hours and cooldown_days . Add documentation for cron to Configuration . Fixes: Remove double reports of connection errors. In case that the user has no drop triggers, the database cleaning interval is set to 120 minutes. Handle requests.exceptions.ConnectionError without crashing. Fix --one-shot mode. It would previously sleep for another interval and not shut down the Telegram logger, preventing the program from a clean exit. Development: Introduce a new pre-commit hook that sorts the import statements. Version 4.3.1 Fixes: Apparently all Kraken trades were sent in the validation mode. I have tried to fix that. Version 4.3.2 Fixes: Fix automatic detection of Telegram chat ID. Do not crash when there is no balance at Kraken. Also handle requests.exceptions.HTTPError . Development: Make the marketplace package isolated, only expose a limited set of attributes in __init__.py . Version 4.3.3 Fixes: Due to an incomplete refactoring the program would crash whenever there was a non-fatal exception regarding the marketplace. This should be fixed now. Version 4.3.4 The --dry-run option would write buys into the database, although it would not buy anything on the market. Now the database should now be changed. If you need to clean up your database, you might find sqliteman helpful for that. I now use the mypy static analysis and type checker, and also found a few subtle bugs with that in code paths which aren't used often. Version 4.3.5 When the balance on the marketplace is zero, withdrawals would fail and therefore crash the whole program. This is now fixed. Version 4.4.0 Major architectural change, without changes to the user. Add test-drive command to verify configuration. Version 4.4.1 More refactoring. Also update the versions of various dependencies. The Streamlit interface is now part of the main dependencies. Version 4.4.2 Streamlit doesn't easily work on the Raspberry Pi due to issues with py-arrow and the ARM CPU. I have therefore reverted these dependencies to be an extra again. Version 4.4.3 I've accidentally deleted the source code. This should be fixed now. Version 4.4.4 The Telegram sender would not shut down gracefully. I have fixed that now. Add --version option.","title":"Version 4"},{"location":"changelog/version-4/#version-4","text":"","title":"Version 4"},{"location":"changelog/version-4/#version-400","text":"The trigger specification is significantly changed. Consult the documentation to learn about the new format. I'm sorry for breaking your configuration, but I didn't want to provide a migration and rather deliver more new features.","title":"Version 4.0.0"},{"location":"changelog/version-4/#version-410","text":"Use krakenex instead of clikraken to communicate with Kraken. The old implementation is deprecated but retained with --marketplace clikraken . Add automatic withdrawal for currency when the amount exceeds a certain threshold determined by the fee. See the configuration of the Kraken marketplace for details.","title":"Version 4.1.0"},{"location":"changelog/version-4/#version-420","text":"\ud83e\uddea New features: Triggers can be given names in the evaluation interface. For the Kraken marketplace you can now specify whether the fees should be applied to base or quote currency. Attach a stack trace of exceptions to the Telegram message. In the drop survey evaluation one now also has a time range slider such that one can get a feeling for the drops. Some are one-time events, and others are regular patterns. \ud83d\udd27 Improvements: The reported balance at startup will only contain currencies which are used in triggers. This will remove some leftover shitcoins that people might left in their account. After a trade only the balances for that currency pair will be reported to give a cleaner report. The legend in the trigger simulation plot is shown below the plot to allow for longer trigger names without having them cropped. Triggers with failures used to get deactivated completely. Once no more triggers were active, the program was shut down. Failures stemming from insufficient funds are easily recovered from by transferring more money to the marketplace. The bot would have to be restarted afterwards. In order to make this unnecessary, failed triggers are just silenced for 12 hours. Another attempt is made automatically afterwards. This keeps the number of messages relatively low. \ud83e\udeb2 Bug fixes: Historical API was broken, it now retrieves data again. Specifying a lower-case fiat currency and using the percentage based fiat volume strategy led to an error. This is now fixed and the fiat currency is again case-insensitive. Make sure that errors from the Telegram API are reported and not ignored. Do not use Markdown with Telegram as parsing errors prevent messages from being sent. Plain text is not as pretty, but better have it reliable no matter which names the Triggers have. Errors from the historical price source have been silently ignored. They now issue a warning. \u2699\ufe0f Implementation details: clikraken has been retired and we now use krakenex in version 2. This version is in conflice with clikraken , which needs krakenex version 1. When you upgrade, you might see this message: ERROR: pip's dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts. clikraken 0.8.3.2 requires krakenex<1.0,>=0.1, but you have krakenex 2.1.0 which is incompatible. To resolve this, run pip uninstall clikraken or sudo pip uninstall clikraken , depending on whether you have installed it with --user in the past. Send Telegram messages via POST (and not GET). Automatically move the SQLite database into the appropriate user data directory on Windows on macOS, no change on Linux.","title":"Version 4.2.0"},{"location":"changelog/version-4/#version-421","text":"When a trigger was disabled after three consecutive failures, a message stating that would be shown every time the trigger was processed. In this way the user got the same amount of messages. This message is now removed. The initial errors speak for themselves, there is no need to have this additional message.","title":"Version 4.2.1"},{"location":"changelog/version-4/#version-422","text":"Another warning message would use a constant that was moved to another place in the meantime. The program crashed when the message was going to be emitted. It has been removed now.","title":"Version 4.2.2"},{"location":"changelog/version-4/#version-423","text":"Log output is also put into the Linux system log. In this way one can do post-mortem debugging. Crashes have been reported when the Telegram message was longer than their limit of 4096 characters. Messages are now chunked to prevent this from happening. Telegram messages are no longer directly send but stored in a send-queue. This way connection outages do not yield lost messages but rather just delay sending. Use a proper form instead of the plain button in Streamlit.","title":"Version 4.2.3"},{"location":"changelog/version-4/#version-424","text":"Also handle ReadTimeout errors that can happen when the API doesn't answer before the connection breaks. These have been ignored previously, but now the error message is a bit cleaner.","title":"Version 4.2.4"},{"location":"changelog/version-4/#version-430","text":"New features: Add a start attributes to triggers. Add --dry-run option to watch command such that it can be tested without spending money. Allow specifying delay and cooldown not only in minutes as delay_minutes and cooldown_minutes , but also as delay_hours , delay_days , cooldown_hours and cooldown_days . Add documentation for cron to Configuration . Fixes: Remove double reports of connection errors. In case that the user has no drop triggers, the database cleaning interval is set to 120 minutes. Handle requests.exceptions.ConnectionError without crashing. Fix --one-shot mode. It would previously sleep for another interval and not shut down the Telegram logger, preventing the program from a clean exit. Development: Introduce a new pre-commit hook that sorts the import statements.","title":"Version 4.3.0"},{"location":"changelog/version-4/#version-431","text":"Fixes: Apparently all Kraken trades were sent in the validation mode. I have tried to fix that.","title":"Version 4.3.1"},{"location":"changelog/version-4/#version-432","text":"Fixes: Fix automatic detection of Telegram chat ID. Do not crash when there is no balance at Kraken. Also handle requests.exceptions.HTTPError . Development: Make the marketplace package isolated, only expose a limited set of attributes in __init__.py .","title":"Version 4.3.2"},{"location":"changelog/version-4/#version-433","text":"Fixes: Due to an incomplete refactoring the program would crash whenever there was a non-fatal exception regarding the marketplace. This should be fixed now.","title":"Version 4.3.3"},{"location":"changelog/version-4/#version-434","text":"The --dry-run option would write buys into the database, although it would not buy anything on the market. Now the database should now be changed. If you need to clean up your database, you might find sqliteman helpful for that. I now use the mypy static analysis and type checker, and also found a few subtle bugs with that in code paths which aren't used often.","title":"Version 4.3.4"},{"location":"changelog/version-4/#version-435","text":"When the balance on the marketplace is zero, withdrawals would fail and therefore crash the whole program. This is now fixed.","title":"Version 4.3.5"},{"location":"changelog/version-4/#version-440","text":"Major architectural change, without changes to the user. Add test-drive command to verify configuration.","title":"Version 4.4.0"},{"location":"changelog/version-4/#version-441","text":"More refactoring. Also update the versions of various dependencies. The Streamlit interface is now part of the main dependencies.","title":"Version 4.4.1"},{"location":"changelog/version-4/#version-442","text":"Streamlit doesn't easily work on the Raspberry Pi due to issues with py-arrow and the ARM CPU. I have therefore reverted these dependencies to be an extra again.","title":"Version 4.4.2"},{"location":"changelog/version-4/#version-443","text":"I've accidentally deleted the source code. This should be fixed now.","title":"Version 4.4.3"},{"location":"changelog/version-4/#version-444","text":"The Telegram sender would not shut down gracefully. I have fixed that now. Add --version option.","title":"Version 4.4.4"},{"location":"changelog/version-5/","text":"Version 5 Version 5.0.0 Refactor a lot more. Remove --keepalive feature, this is on by default now. Remove --dry-run feature, use the test-drive command instead. Remove --one-shot feature, use the loop instead. Version 5.0.1 Fix bug with marketplace factory function. Would emit RuntimeError: Unsupported marketplace: <vigilant_crypto_snatch.configuration.yaml_configuration.YamlConfiguration object at 0x7f2b3a031840> . Version 5.0.2 The Telegram connector would hang during shutdown, I have fixed that again. Version 5.0.3 Catch requests.exceptions.ConnectionError , which wasn't caught by the krakenex library. Now it will be converted into an error on the module level. Version 5.1.0 Print out version number during startup. Add trigger option fear_and_greed_index_below . Version 5.2.0 Fear & Greed is now included in the evaluation interface. More refactoring, more test coverage. Developer documentation includes a component diagram. Version 5.2.1 Allow any log level for Telegram, including debug . Attempt withdrawal after the trade has been noted in the database. Previously, a failure during withdrawal would have dropped the trade and eventually performed it again. Output full exception traceback for every caught exception into the debug logging channel. Pause triggers for 24 hours when they have insufficient funds. This will reduce failure messages from three per 12 hours to one per 24 hours. Version 5.3.0 Add a report page about user trades into the evaluation interface. Link to download statistics within documentation. Add GitHub funding. Connection errors are not reported all the time, instead they are just logged as debug output. Create AssetPair data structure so better structure the code internally. Remove usage of Protocol such that Python 3.7 is still supported. Update developer documentation a bit. Update Pillow for security. Version 5.3.1 Fix bug in trade report with KeyError: 'coin' . Version 5.4.0 Add optional and voluntary telemetry sending via Sentry. See the configuration for details and how to enable it, if you want to. Add a dark mode to the documentation. Split configuration documentation onto multiple pages. Version 5.4.1 Remove the telemetry stuff again. Split usage documentation onto multiple pages. Restore Windows support by only adding syslog on Linux. Version 5.4.2 Fix path handling to database on Windows. Version 5.4.3 The database cleaning trigger would always clean all historic prices which were two hours in the past. Therefore all old prices would vanish and a lot of calls to CryptoCompare were done. This depleted the API volume needlessly. The Fear and Greed index sometimes doesn't deliver a value for the current day. In this case we will try the value from yesterday. If that doesn't exist as well, the failure will just be logged, without crashing the program. Version 5.4.4 The krakenex library would sometimes also raise a requests.exceptions.ReadTimeout , which was not caught. The program would crash. This exception type is now caught as well. Version 5.5.0 The CCXT library is now supported and gives access to more over a 100 more exchanges. Add an asset pair selector in the trade overview panel in the evaluation interface. Also add documentation for the trade overview. It is now an error when either drop percentage or delay is given, but not both at the same time. Previously this would have lead to a simple delay trigger, although the user likely wanted to have a drop trigger. The error message will make it clear that users have to update their configuration. The --marketplace command line option has been removed, the marketplace is now chosen via an entry in the configuration file. Version 5.6.0 Add support for notifications via notify.run to provide an alternative to Telegram. Also catch HTTPError in the krakenex wrapper. Version 5.7.0 A completely new GUI using Qt is now part of the project. The trigger start attribute used to discard the time part, if it was given. The start was always taken to start from midnight. This is fixed in this version. Version 5.8.0 All triggers now need to have an explicit name set in the configuration. The GUI has an improved status and about screen. The GUI now shows a system tray icon and can send notifications. Logo added to the GUI window. Version 5.8.1 Allow setting a start date and time in the GUI.","title":"Version 5"},{"location":"changelog/version-5/#version-5","text":"","title":"Version 5"},{"location":"changelog/version-5/#version-500","text":"Refactor a lot more. Remove --keepalive feature, this is on by default now. Remove --dry-run feature, use the test-drive command instead. Remove --one-shot feature, use the loop instead.","title":"Version 5.0.0"},{"location":"changelog/version-5/#version-501","text":"Fix bug with marketplace factory function. Would emit RuntimeError: Unsupported marketplace: <vigilant_crypto_snatch.configuration.yaml_configuration.YamlConfiguration object at 0x7f2b3a031840> .","title":"Version 5.0.1"},{"location":"changelog/version-5/#version-502","text":"The Telegram connector would hang during shutdown, I have fixed that again.","title":"Version 5.0.2"},{"location":"changelog/version-5/#version-503","text":"Catch requests.exceptions.ConnectionError , which wasn't caught by the krakenex library. Now it will be converted into an error on the module level.","title":"Version 5.0.3"},{"location":"changelog/version-5/#version-510","text":"Print out version number during startup. Add trigger option fear_and_greed_index_below .","title":"Version 5.1.0"},{"location":"changelog/version-5/#version-520","text":"Fear & Greed is now included in the evaluation interface. More refactoring, more test coverage. Developer documentation includes a component diagram.","title":"Version 5.2.0"},{"location":"changelog/version-5/#version-521","text":"Allow any log level for Telegram, including debug . Attempt withdrawal after the trade has been noted in the database. Previously, a failure during withdrawal would have dropped the trade and eventually performed it again. Output full exception traceback for every caught exception into the debug logging channel. Pause triggers for 24 hours when they have insufficient funds. This will reduce failure messages from three per 12 hours to one per 24 hours.","title":"Version 5.2.1"},{"location":"changelog/version-5/#version-530","text":"Add a report page about user trades into the evaluation interface. Link to download statistics within documentation. Add GitHub funding. Connection errors are not reported all the time, instead they are just logged as debug output. Create AssetPair data structure so better structure the code internally. Remove usage of Protocol such that Python 3.7 is still supported. Update developer documentation a bit. Update Pillow for security.","title":"Version 5.3.0"},{"location":"changelog/version-5/#version-531","text":"Fix bug in trade report with KeyError: 'coin' .","title":"Version 5.3.1"},{"location":"changelog/version-5/#version-540","text":"Add optional and voluntary telemetry sending via Sentry. See the configuration for details and how to enable it, if you want to. Add a dark mode to the documentation. Split configuration documentation onto multiple pages.","title":"Version 5.4.0"},{"location":"changelog/version-5/#version-541","text":"Remove the telemetry stuff again. Split usage documentation onto multiple pages. Restore Windows support by only adding syslog on Linux.","title":"Version 5.4.1"},{"location":"changelog/version-5/#version-542","text":"Fix path handling to database on Windows.","title":"Version 5.4.2"},{"location":"changelog/version-5/#version-543","text":"The database cleaning trigger would always clean all historic prices which were two hours in the past. Therefore all old prices would vanish and a lot of calls to CryptoCompare were done. This depleted the API volume needlessly. The Fear and Greed index sometimes doesn't deliver a value for the current day. In this case we will try the value from yesterday. If that doesn't exist as well, the failure will just be logged, without crashing the program.","title":"Version 5.4.3"},{"location":"changelog/version-5/#version-544","text":"The krakenex library would sometimes also raise a requests.exceptions.ReadTimeout , which was not caught. The program would crash. This exception type is now caught as well.","title":"Version 5.4.4"},{"location":"changelog/version-5/#version-550","text":"The CCXT library is now supported and gives access to more over a 100 more exchanges. Add an asset pair selector in the trade overview panel in the evaluation interface. Also add documentation for the trade overview. It is now an error when either drop percentage or delay is given, but not both at the same time. Previously this would have lead to a simple delay trigger, although the user likely wanted to have a drop trigger. The error message will make it clear that users have to update their configuration. The --marketplace command line option has been removed, the marketplace is now chosen via an entry in the configuration file.","title":"Version 5.5.0"},{"location":"changelog/version-5/#version-560","text":"Add support for notifications via notify.run to provide an alternative to Telegram. Also catch HTTPError in the krakenex wrapper.","title":"Version 5.6.0"},{"location":"changelog/version-5/#version-570","text":"A completely new GUI using Qt is now part of the project. The trigger start attribute used to discard the time part, if it was given. The start was always taken to start from midnight. This is fixed in this version.","title":"Version 5.7.0"},{"location":"changelog/version-5/#version-580","text":"All triggers now need to have an explicit name set in the configuration. The GUI has an improved status and about screen. The GUI now shows a system tray icon and can send notifications. Logo added to the GUI window.","title":"Version 5.8.0"},{"location":"changelog/version-5/#version-581","text":"Allow setting a start date and time in the GUI.","title":"Version 5.8.1"},{"location":"configuration/general/","text":"General Configuration Unfortunately we need to configure a few things before you can start automatic trading with this software. Most configuration is done in a YAML file. It is a syntax for hierarchical data and relies on indentation to show the hierarchy. Since version 5.7.0 we also have a graphical user interface which will help you to configure the program. You can also directly use the graphical user interface along this guide. The configuration file needs to be created with a (programmer's) text editor. We will talk you through the necessary steps and show snippets to put into. Depending on your platform, the path should be this: Platform Location Linux ~/.config/vigilant-crypto-snatch/config.yml Windows C:\\Users\\<User>\\Application Data\\Martin Ueding\\vigilant-crypto-snatch\\config.yml macOS ~/Library/Application Support/vigilant-crypto-snatch/config.yml This page does not contain all the necessary configuration steps, see the navigation for further pages on marketplaces , triggers and notifications . Polling interval First you should set the polling interval that the main loop should use. It will wait this many seconds before checking again. For testing we found that 5 seconds is a good value, for production use it doesn't need to be that fine grained. Many people use 60 seconds, but one can also use a whole hour. sleep : 60 Historic price API In order to find a drop in the price, we need to know the historic price at a given point. We use Crypto Compare for that as they provide a free API. Go to their website and create an API key. And retrieve your API key: In the configuration file then add the following: cryptocompare : api_key : \"your API key here\"","title":"General Configuration"},{"location":"configuration/general/#general-configuration","text":"Unfortunately we need to configure a few things before you can start automatic trading with this software. Most configuration is done in a YAML file. It is a syntax for hierarchical data and relies on indentation to show the hierarchy. Since version 5.7.0 we also have a graphical user interface which will help you to configure the program. You can also directly use the graphical user interface along this guide. The configuration file needs to be created with a (programmer's) text editor. We will talk you through the necessary steps and show snippets to put into. Depending on your platform, the path should be this: Platform Location Linux ~/.config/vigilant-crypto-snatch/config.yml Windows C:\\Users\\<User>\\Application Data\\Martin Ueding\\vigilant-crypto-snatch\\config.yml macOS ~/Library/Application Support/vigilant-crypto-snatch/config.yml This page does not contain all the necessary configuration steps, see the navigation for further pages on marketplaces , triggers and notifications .","title":"General Configuration"},{"location":"configuration/general/#polling-interval","text":"First you should set the polling interval that the main loop should use. It will wait this many seconds before checking again. For testing we found that 5 seconds is a good value, for production use it doesn't need to be that fine grained. Many people use 60 seconds, but one can also use a whole hour. sleep : 60","title":"Polling interval"},{"location":"configuration/general/#historic-price-api","text":"In order to find a drop in the price, we need to know the historic price at a given point. We use Crypto Compare for that as they provide a free API. Go to their website and create an API key. And retrieve your API key: In the configuration file then add the following: cryptocompare : api_key : \"your API key here\"","title":"Historic price API"},{"location":"configuration/marketplace/","text":"Marketplaces We currently support two marketplaces directly, Bitstamp and Kraken . We support many more via the CCXT library. You only have to configure one of them, but you can also configure multiple. You just have to specify which marketplace you want to use via another entry in the YAML file: marketplace : \"kraken\" You can specify either kraken , bitstamp or ccxt . The default currently is kraken . Kraken Go to the Kraken API key page and create an API key which has the permission to trade. There you need to create a new API key: Be sure to select the Create & Modify Orders permission such that the program can actually execute orders. Give the least amount of permissions, you should not select Withdraw Funds if you don't want to enable the automatic withdrawal feature described below. You will get an API key and an associated secret. In the configuration file you add a paragraph like the following. The first will be API key and the second will be the secret, like this: kraken : key : \"YOUR KEY\" secret : \"YOUR SECRET\" Fee policy When you trade, you will have to pay a certain fee that depends on your Kraken account tier. Whatever these are exactly, you can choose whether you would like to have them taken away from your fiat or coin amount. If you let it take away from your coin amount, buying coin for 50 EUR will only cost exactly that, but you get a bit less coin. Should you rather choose to have it taken in fiat, you will get as much coin as you want, but it will cost you more fiat. Kraken supports this as a flag to addOrder and has two options: fcib prefer fee in base currency (default if selling) fciq prefer fee in quote currency (default if buying, mutually exclusive with fcib ) As explained in their glossary , the quote currency is fiat, whereas the base currency is the coin. We support this choice via the option prefer_fee_in_base_currency , which is false by default, so the fee is preferred in quote currency. If you set this to true, you can instead have it in the base currency and only spend exactly as much as you want. For this add this line: kraken : \u2026 prefer_fee_in_base_currency : true Automatic transfer to wallet For this marketplace we support automatic transfers to an external wallet when the crypto volume is large enough. We query the current fees and only do the transfer when the fees are below a certain percentage of the value to transfer. In order to set this up, you first need to have a withdrawal target. Go to the funding page , click on withdraw BTC for example. Then use \u201cAdd Address\u201d to create a new address and give it some name. I call mine simply \u201cWallet\u201d. Then for each currency that you want to set up withdrawal for, add a matching group in the kraken section like this: kraken : \u2026 withdrawal : BTC : target : \"Wallet\" fee_limit_percent : 1.0 The API key that you use must have the Withdraw Funds permission. After each trade the program will check whether you are above the fee limit and start the transfer. This way you can have your marketplace account as empty as you like. Bitstamp In order to use Bitstamp, you need to set up an API key with them that has the correct permissions to trade with. Go to the settings menu and create a new key. Put this API key into the configuration file. bitstamp : username : \"username here\" key : \"key here\" secret : \"secret here\" Other exchanges via CCXT Via the CCXT library we also support a long list of exchanges . We don't fully wrap the CCXT library but rather expose it to the user. This way you can use all the exchanges directly without us having to change this software at all. The caveat is that it is not directly clear what the configuration parameters should be. Likely most exchanges expect apiKey and secret . In our configuration file you specify a block for ccxt and then name the exchange you want to use, taken from their list of exchanges. In the parameters section you specify the necessary parameters. We will pass those directly to CCXT. ccxt : exchange : kraken parameters : apiKey : \"\u2026\" secret : \"\u2026\"","title":"Marketplaces"},{"location":"configuration/marketplace/#marketplaces","text":"We currently support two marketplaces directly, Bitstamp and Kraken . We support many more via the CCXT library. You only have to configure one of them, but you can also configure multiple. You just have to specify which marketplace you want to use via another entry in the YAML file: marketplace : \"kraken\" You can specify either kraken , bitstamp or ccxt . The default currently is kraken .","title":"Marketplaces"},{"location":"configuration/marketplace/#kraken","text":"Go to the Kraken API key page and create an API key which has the permission to trade. There you need to create a new API key: Be sure to select the Create & Modify Orders permission such that the program can actually execute orders. Give the least amount of permissions, you should not select Withdraw Funds if you don't want to enable the automatic withdrawal feature described below. You will get an API key and an associated secret. In the configuration file you add a paragraph like the following. The first will be API key and the second will be the secret, like this: kraken : key : \"YOUR KEY\" secret : \"YOUR SECRET\"","title":"Kraken"},{"location":"configuration/marketplace/#fee-policy","text":"When you trade, you will have to pay a certain fee that depends on your Kraken account tier. Whatever these are exactly, you can choose whether you would like to have them taken away from your fiat or coin amount. If you let it take away from your coin amount, buying coin for 50 EUR will only cost exactly that, but you get a bit less coin. Should you rather choose to have it taken in fiat, you will get as much coin as you want, but it will cost you more fiat. Kraken supports this as a flag to addOrder and has two options: fcib prefer fee in base currency (default if selling) fciq prefer fee in quote currency (default if buying, mutually exclusive with fcib ) As explained in their glossary , the quote currency is fiat, whereas the base currency is the coin. We support this choice via the option prefer_fee_in_base_currency , which is false by default, so the fee is preferred in quote currency. If you set this to true, you can instead have it in the base currency and only spend exactly as much as you want. For this add this line: kraken : \u2026 prefer_fee_in_base_currency : true","title":"Fee policy"},{"location":"configuration/marketplace/#automatic-transfer-to-wallet","text":"For this marketplace we support automatic transfers to an external wallet when the crypto volume is large enough. We query the current fees and only do the transfer when the fees are below a certain percentage of the value to transfer. In order to set this up, you first need to have a withdrawal target. Go to the funding page , click on withdraw BTC for example. Then use \u201cAdd Address\u201d to create a new address and give it some name. I call mine simply \u201cWallet\u201d. Then for each currency that you want to set up withdrawal for, add a matching group in the kraken section like this: kraken : \u2026 withdrawal : BTC : target : \"Wallet\" fee_limit_percent : 1.0 The API key that you use must have the Withdraw Funds permission. After each trade the program will check whether you are above the fee limit and start the transfer. This way you can have your marketplace account as empty as you like.","title":"Automatic transfer to wallet"},{"location":"configuration/marketplace/#bitstamp","text":"In order to use Bitstamp, you need to set up an API key with them that has the correct permissions to trade with. Go to the settings menu and create a new key. Put this API key into the configuration file. bitstamp : username : \"username here\" key : \"key here\" secret : \"secret here\"","title":"Bitstamp"},{"location":"configuration/marketplace/#other-exchanges-via-ccxt","text":"Via the CCXT library we also support a long list of exchanges . We don't fully wrap the CCXT library but rather expose it to the user. This way you can use all the exchanges directly without us having to change this software at all. The caveat is that it is not directly clear what the configuration parameters should be. Likely most exchanges expect apiKey and secret . In our configuration file you specify a block for ccxt and then name the exchange you want to use, taken from their list of exchanges. In the parameters section you specify the necessary parameters. We will pass those directly to CCXT. ccxt : exchange : kraken parameters : apiKey : \"\u2026\" secret : \"\u2026\"","title":"Other exchanges via CCXT"},{"location":"configuration/notifications/","text":"Notifications Optionally you can set up notifications via several external services. This is not required, but a nice extra to allow monitoring from anywhere. You can configure zero or multiple notification providers, they will then all be used in parallel. Logging level The level specified the messages that you want to receive. info gives sensible information, if you only want to receive information when something goes wrong, use warning . See the section in running for more details. The severity of messages is color-coded with an emoji according to this mapping: Symbol Severity \ud83d\udd34 Critical \ud83d\udfe0 Error \ud83d\udfe1 Warning \ud83d\udfe2 Info \ud83d\udd35 Debug The logging level is set to Info by default. Telegram One popular choice for notifications is Telegram. First you have to create a bot by talking to @botfather . It will lead you through a couple of steps: Type /start to initiate the bot creation. Then type /newbot to create your bot. It will ask you for the name of the bot. You can just use \u201cvigilant-crypto-snatch\u201d or something else. Next it will ask for a username of the bot. This is a technical thing, so it doesn't need to be pretty. It needs to be unique and end with bot . So perhaps use something like vigilant_0f8704a83991_bot , where you just make up your own random letters. It will give you an access token that you can use for the API. Enter that token into the configuration file: telegram : token : \"Your bot token here\" level : info You will need to write a message to the bot in order to open a direct conversation with it. This is necessary such that the bot can reply to you. If the Telegram bot token is set up correctly, you will receive messages like this: notify.run The service notify.run offers free notifications which are very simple to set up. One does not need to register, one can just create a new channel. They recommend to not send private data the service. As I understand it, if somebody was to guess the channel ID (unlikely), they would be able to see all notifications. Also, it is not clear where the data is stored and for how long. Go to their website, click on \u201ccreate a channel\u201d. It will give you a channel ID, which you need to add to the configuration file like so: notify_run: channel: \"\u2026\" level: info","title":"Notifications"},{"location":"configuration/notifications/#notifications","text":"Optionally you can set up notifications via several external services. This is not required, but a nice extra to allow monitoring from anywhere. You can configure zero or multiple notification providers, they will then all be used in parallel.","title":"Notifications"},{"location":"configuration/notifications/#logging-level","text":"The level specified the messages that you want to receive. info gives sensible information, if you only want to receive information when something goes wrong, use warning . See the section in running for more details. The severity of messages is color-coded with an emoji according to this mapping: Symbol Severity \ud83d\udd34 Critical \ud83d\udfe0 Error \ud83d\udfe1 Warning \ud83d\udfe2 Info \ud83d\udd35 Debug The logging level is set to Info by default.","title":"Logging level"},{"location":"configuration/notifications/#telegram","text":"One popular choice for notifications is Telegram. First you have to create a bot by talking to @botfather . It will lead you through a couple of steps: Type /start to initiate the bot creation. Then type /newbot to create your bot. It will ask you for the name of the bot. You can just use \u201cvigilant-crypto-snatch\u201d or something else. Next it will ask for a username of the bot. This is a technical thing, so it doesn't need to be pretty. It needs to be unique and end with bot . So perhaps use something like vigilant_0f8704a83991_bot , where you just make up your own random letters. It will give you an access token that you can use for the API. Enter that token into the configuration file: telegram : token : \"Your bot token here\" level : info You will need to write a message to the bot in order to open a direct conversation with it. This is necessary such that the bot can reply to you. If the Telegram bot token is set up correctly, you will receive messages like this:","title":"Telegram"},{"location":"configuration/notifications/#notifyrun","text":"The service notify.run offers free notifications which are very simple to set up. One does not need to register, one can just create a new channel. They recommend to not send private data the service. As I understand it, if somebody was to guess the channel ID (unlikely), they would be able to see all notifications. Also, it is not clear where the data is stored and for how long. Go to their website, click on \u201ccreate a channel\u201d. It will give you a channel ID, which you need to add to the configuration file like so: notify_run: channel: \"\u2026\" level: info","title":"notify.run"},{"location":"configuration/triggers/","text":"Triggers You can define as many triggers as you would like. This is done in a section triggers . Let us show an example first and explain all the keys below. triggers : - name : \"Large drops\" coin : btc fiat : eur cooldown_minutes : 1440 volume_fiat : 26.0 delay_minutes : 1440 drop_percentage : 10 - name : \"Medium drops\" coin : btc fiat : eur cooldown_minutes : 1440 volume_fiat : 26.0 delay_minutes : 1440 drop_percentage : 5 - name : \"Regular\" coin : btc fiat : eur cooldown_minutes : 5000 volume_fiat : 26.0 There are different sub-types, but all of them have the following elements in common: coin : The name of the crypto-currency, case insensitive. fiat : The name of the fiat currency, case insensitive. cooldown_minutes , cooldown_hours , cooldown_days : Time until a trigger can fire again. If multiple ones are given, only the one with the largest unit will be used. name : Human-readable name of the trigger. The internal name of the trigger can be derived from the options. This will give you technical names in notifications, so you might prefer to give them personal names. Additionally the name is used in the database to compute the cooldown. If you don't have a name specified and change any of the parameters, the internal name will change and cooldown doesn't apply any more. start : Optional date time string which specifies the earliest execution of the trigger. This can be used if you have just created a bunch of new triggers, or made changes to them without keeping the name attribute fixed. By specifying a future point in time you can prepare a trigger without having it executed on the next run of the program. We use dateutil.parser to parse the date. It will understand most formats, but the ISO format ( YYYY-MM-DD HH:MM:SS ) will certainly work. Trigger strategy We currently have two optional trigger strategies. All strategies also use the cooldown. If you do not specify any strategy keys, then it will just buy whenever the cooldown has expired. This is the \u201cDollar cost average\u201d way. You can use as many strategies as you like. They are connected via logical and , meaning that all strategies have to say \u201cbuy\u201d in order for the trigger to fire. Drop strategy The first strategy is the drop strategy. It will look whether the price has dropped by a given percentage within a given delay . You could for instance look for a drop of 1 % within 60 minutes. You will need to specify these keys: drop_percentage delay_minutes , delay_hours or delay_days : If multiple are given, only the one with the largest unit will be used. You can specify a decimal number for the drop percentage, just be aware that it must contain a decimal point instead of a decimal comma. Fear & Greed strategy There is the Fear & Greed Index , which provides a market analysis via multiple factors. It is a number between 0 and 100. Low numbers mean that people are fearful and it might be good to buy. And high numbers mean that people are greedy and it might be a bad idea to buy. You can specify the following key to make use of this strategy. fear_and_greed_index_below : An integer value between 0 and 101 which is the exclusive upper limit for the fear and greed index. If you specify 50, then it will only buy for 49 or below. Fiat volume strategy There are two ways that you can determine the amount of fiat volume that you want to spend on each trigger execution. First there is the fixed strategy, where you always spend a fixed amount. For that you need this key: volume_fiat : Amount in fiat currency. Alternatively you can specify a percentage of the amount of fiat currency that you have on the market. For this specify a percentage: percentage_fiat : Percentage of fiat money to spend in each buy. Choosing sensible values But what shall I choose? What will give me the most return of investment? We don't have the truth either, but we recommend that you take a look at the evaluation interface that is linked on the usage page. The heatmap of drops gives you a good idea of which delays and drop percentages to use. The trigger simulation gives you an idea of how often they fire, and let you choose the amount of fiat to spend. You can also come to the Telegram group, see support , and ask other users for their experience.","title":"Triggers"},{"location":"configuration/triggers/#triggers","text":"You can define as many triggers as you would like. This is done in a section triggers . Let us show an example first and explain all the keys below. triggers : - name : \"Large drops\" coin : btc fiat : eur cooldown_minutes : 1440 volume_fiat : 26.0 delay_minutes : 1440 drop_percentage : 10 - name : \"Medium drops\" coin : btc fiat : eur cooldown_minutes : 1440 volume_fiat : 26.0 delay_minutes : 1440 drop_percentage : 5 - name : \"Regular\" coin : btc fiat : eur cooldown_minutes : 5000 volume_fiat : 26.0 There are different sub-types, but all of them have the following elements in common: coin : The name of the crypto-currency, case insensitive. fiat : The name of the fiat currency, case insensitive. cooldown_minutes , cooldown_hours , cooldown_days : Time until a trigger can fire again. If multiple ones are given, only the one with the largest unit will be used. name : Human-readable name of the trigger. The internal name of the trigger can be derived from the options. This will give you technical names in notifications, so you might prefer to give them personal names. Additionally the name is used in the database to compute the cooldown. If you don't have a name specified and change any of the parameters, the internal name will change and cooldown doesn't apply any more. start : Optional date time string which specifies the earliest execution of the trigger. This can be used if you have just created a bunch of new triggers, or made changes to them without keeping the name attribute fixed. By specifying a future point in time you can prepare a trigger without having it executed on the next run of the program. We use dateutil.parser to parse the date. It will understand most formats, but the ISO format ( YYYY-MM-DD HH:MM:SS ) will certainly work.","title":"Triggers"},{"location":"configuration/triggers/#trigger-strategy","text":"We currently have two optional trigger strategies. All strategies also use the cooldown. If you do not specify any strategy keys, then it will just buy whenever the cooldown has expired. This is the \u201cDollar cost average\u201d way. You can use as many strategies as you like. They are connected via logical and , meaning that all strategies have to say \u201cbuy\u201d in order for the trigger to fire.","title":"Trigger strategy"},{"location":"configuration/triggers/#drop-strategy","text":"The first strategy is the drop strategy. It will look whether the price has dropped by a given percentage within a given delay . You could for instance look for a drop of 1 % within 60 minutes. You will need to specify these keys: drop_percentage delay_minutes , delay_hours or delay_days : If multiple are given, only the one with the largest unit will be used. You can specify a decimal number for the drop percentage, just be aware that it must contain a decimal point instead of a decimal comma.","title":"Drop strategy"},{"location":"configuration/triggers/#fear-greed-strategy","text":"There is the Fear & Greed Index , which provides a market analysis via multiple factors. It is a number between 0 and 100. Low numbers mean that people are fearful and it might be good to buy. And high numbers mean that people are greedy and it might be a bad idea to buy. You can specify the following key to make use of this strategy. fear_and_greed_index_below : An integer value between 0 and 101 which is the exclusive upper limit for the fear and greed index. If you specify 50, then it will only buy for 49 or below.","title":"Fear &amp; Greed strategy"},{"location":"configuration/triggers/#fiat-volume-strategy","text":"There are two ways that you can determine the amount of fiat volume that you want to spend on each trigger execution. First there is the fixed strategy, where you always spend a fixed amount. For that you need this key: volume_fiat : Amount in fiat currency. Alternatively you can specify a percentage of the amount of fiat currency that you have on the market. For this specify a percentage: percentage_fiat : Percentage of fiat money to spend in each buy.","title":"Fiat volume strategy"},{"location":"configuration/triggers/#choosing-sensible-values","text":"But what shall I choose? What will give me the most return of investment? We don't have the truth either, but we recommend that you take a look at the evaluation interface that is linked on the usage page. The heatmap of drops gives you a good idea of which delays and drop percentages to use. The trigger simulation gives you an idea of how often they fire, and let you choose the amount of fiat to spend. You can also come to the Telegram group, see support , and ask other users for their experience.","title":"Choosing sensible values"},{"location":"dev/components/","text":"Components This project aims to be organized according to the Clean Architecture . There are many components, and they only depend on each other in an acyclic way. First we show a diagram which contains just opaque components. The parts from this software are yellow, the external libraries are in blue. You can see that is a nice directed acyclic graph, and that the core component is independent of any external libraries. On this page we will go through all the components and how they interact with each other. This shall give you an overview of the architecture of this software. Core At the center there are the core entities, the data classes which don't depend on anything else. These are the classes representing Price and Trade . These are implemented as dataclasses . Datastore The next component is the data storage. We have an interface which allows to store price and trade objects and retrieve them. We also have a clean-up operation, and two specific queries. It is implemented using simple lists for testing, and also using the SQL Alchemy library. One can see that although this depends on an external library, it is only used in a concrete implementation of the interface. The other code doesn't expliclty depend on this storage implementation but only on the interface. And thus we have decoupled it. Marketplace Since we buy crypto currency, we need to have a marketplace. This is also hidden behind the Marketplace interface which offers a few functions. It is not a complete wrapper of any particular marketplace, but just what we need in this project. There are two concrete implementations, namely for the Kraken and Bitstamp exchanges. These implementations depend on the external libraries. Again the remainder of the code only depends on the interface. My Requests There are multiple parts in the code where I need to issue HTTP requests. For this the requests library is an excellent choice. I just don't want the exception handling to spill all over my code, so I wrap it and just catch all possible exceptions there. Historical In order to find drops, we need to know the prices in the past. These are provided by a historical source, which delivers price objects. There are many different implementations. One just asks the marketplace for the current price, that only works when the specified time is right now. For older times we can have a look into the database. But if there is no appropriate price available, it will ask on Crypto Compare. To the remainder of the program everything is hidden behind that interface. Fear & Greed For the \u201cFear & Greed Index\u201d we need to query the API. This again has an interface, such that we can test it. Triggers The triggers get specified by the user. I have generalized the trigger concept such that it just handles regular actions. These also include database cleaning and sending a Telegram notification. For the buy triggers there is a specification, the TriggerSpec . The buy trigger uses two delegates as part of the strategy pattern . One is used to determine the amount of fiat money to spend, the other is whether the trigger should be considered active. This lets us mix and match these algorithms without having an exploding inheritance hierarchy. Dependencies to other parts of the code are via the interfaces only, this way it is decoupled. Paths We need to know where to store and load configuration files, database files and cached information. For this we have the collected the paths in a module. This uses the appdir library to get user directories in a system independent manner. Telegram The message sending to Telegram is implemented as a logger with the Python standard library logging facilities. I have a logger which extends the handler. In this way I depend on something external, but it is pluggable via the logging handler mechanism in the standard library. I use the requests library for the HTTP requests, which I did not hide behind an interface. Configuration The configuration shall be independent of the file format used, it should provide some migrations and so on. All the parsing should be done there as well. At the moment I have a bunch of free functions, and they pass around lists and dicts. I am not that happy with that yet, I would like to have an interface there as well in order to mock that for tests. Commands The main commands then import a bunch of the concrete classes and instantiates that. This is okay, because that is on the outside ring of my architecture. Everything I also have a diagram where everything is put together. It is quite big, so click on it to view the full graphics. It is a bit harder to see, but the dependencies are acyclic. You can also see this from this page, where I was able to introduce the parts without having to forward declare something to be used later. Everything neatly built atop of existing things only.","title":"Components"},{"location":"dev/components/#components","text":"This project aims to be organized according to the Clean Architecture . There are many components, and they only depend on each other in an acyclic way. First we show a diagram which contains just opaque components. The parts from this software are yellow, the external libraries are in blue. You can see that is a nice directed acyclic graph, and that the core component is independent of any external libraries. On this page we will go through all the components and how they interact with each other. This shall give you an overview of the architecture of this software.","title":"Components"},{"location":"dev/components/#core","text":"At the center there are the core entities, the data classes which don't depend on anything else. These are the classes representing Price and Trade . These are implemented as dataclasses .","title":"Core"},{"location":"dev/components/#datastore","text":"The next component is the data storage. We have an interface which allows to store price and trade objects and retrieve them. We also have a clean-up operation, and two specific queries. It is implemented using simple lists for testing, and also using the SQL Alchemy library. One can see that although this depends on an external library, it is only used in a concrete implementation of the interface. The other code doesn't expliclty depend on this storage implementation but only on the interface. And thus we have decoupled it.","title":"Datastore"},{"location":"dev/components/#marketplace","text":"Since we buy crypto currency, we need to have a marketplace. This is also hidden behind the Marketplace interface which offers a few functions. It is not a complete wrapper of any particular marketplace, but just what we need in this project. There are two concrete implementations, namely for the Kraken and Bitstamp exchanges. These implementations depend on the external libraries. Again the remainder of the code only depends on the interface.","title":"Marketplace"},{"location":"dev/components/#my-requests","text":"There are multiple parts in the code where I need to issue HTTP requests. For this the requests library is an excellent choice. I just don't want the exception handling to spill all over my code, so I wrap it and just catch all possible exceptions there.","title":"My Requests"},{"location":"dev/components/#historical","text":"In order to find drops, we need to know the prices in the past. These are provided by a historical source, which delivers price objects. There are many different implementations. One just asks the marketplace for the current price, that only works when the specified time is right now. For older times we can have a look into the database. But if there is no appropriate price available, it will ask on Crypto Compare. To the remainder of the program everything is hidden behind that interface.","title":"Historical"},{"location":"dev/components/#fear-greed","text":"For the \u201cFear & Greed Index\u201d we need to query the API. This again has an interface, such that we can test it.","title":"Fear &amp; Greed"},{"location":"dev/components/#triggers","text":"The triggers get specified by the user. I have generalized the trigger concept such that it just handles regular actions. These also include database cleaning and sending a Telegram notification. For the buy triggers there is a specification, the TriggerSpec . The buy trigger uses two delegates as part of the strategy pattern . One is used to determine the amount of fiat money to spend, the other is whether the trigger should be considered active. This lets us mix and match these algorithms without having an exploding inheritance hierarchy. Dependencies to other parts of the code are via the interfaces only, this way it is decoupled.","title":"Triggers"},{"location":"dev/components/#paths","text":"We need to know where to store and load configuration files, database files and cached information. For this we have the collected the paths in a module. This uses the appdir library to get user directories in a system independent manner.","title":"Paths"},{"location":"dev/components/#telegram","text":"The message sending to Telegram is implemented as a logger with the Python standard library logging facilities. I have a logger which extends the handler. In this way I depend on something external, but it is pluggable via the logging handler mechanism in the standard library. I use the requests library for the HTTP requests, which I did not hide behind an interface.","title":"Telegram"},{"location":"dev/components/#configuration","text":"The configuration shall be independent of the file format used, it should provide some migrations and so on. All the parsing should be done there as well. At the moment I have a bunch of free functions, and they pass around lists and dicts. I am not that happy with that yet, I would like to have an interface there as well in order to mock that for tests.","title":"Configuration"},{"location":"dev/components/#commands","text":"The main commands then import a bunch of the concrete classes and instantiates that. This is okay, because that is on the outside ring of my architecture.","title":"Commands"},{"location":"dev/components/#everything","text":"I also have a diagram where everything is put together. It is quite big, so click on it to view the full graphics. It is a bit harder to see, but the dependencies are acyclic. You can also see this from this page, where I was able to introduce the parts without having to forward declare something to be used later. Everything neatly built atop of existing things only.","title":"Everything"},{"location":"installation/general/","text":"Installation The project is published on PyPI , so you can just install it with PIP. We have split some functionality into an extra such that you can install just the base trading part on a little system that is running the whole time (like a Raspberry Pi). On your main workstation you can install the full software such that you can use the evaluation interface. To install just the base package system wide, run this: sudo python3 -m pip install vigilant-crypto-snatch If you are not running on a Raspberry Pi with 32 bit Linux, you can also install the evaluation interface and/or the GUI with the following square bracket syntax, where you can either include evaluation , gui or evaluation,gui . sudo python3 -m pip install 'vigilant-crypto-snatch[evaluation,gui]' If you don't want to install it system-wide, you can instead use python3 -p pip install --user vigilant . In that case you have to make sure that ~/.local/bin is part of your PATH environment variable. Once you are done with the installation, go over to the configuration . Virtualenv Maybe you want to install the software and all its dependencies into a virtual environment. For this first create a virtual environment: $ virtualenv /tmp/vigilant-crypto-snatch-5-2-0 created virtual environment CPython3.10.1.final.0-64 in 485ms Choose a directory that makes sense for you, like ~/.local/share/virtualenvs/vigilant-crypto-snatch . Then activate the virtual environment: $ source /tmo/vigilant-crypto-snatch-5-2-0/bin/activate And now you can install it via pip, as usual: $ pip install --upgrade vigilant-crypto-snatch Whenever you want to use it, you will first need to activate the environment and then you can just call vigilant-crypto-snatch . Upgrades If you want to upgrade use: sudo python3 -m pip install vigilant-crypto-snatch --upgrade In case you have installed it differently, you will likely also need to upgrade in the same way. We sometimes update the configuration options a bit and don't offer an automated migration path. You will likely get some errors on startup. Please consult the documentation to see how configuration works with the current version.","title":"Installation"},{"location":"installation/general/#installation","text":"The project is published on PyPI , so you can just install it with PIP. We have split some functionality into an extra such that you can install just the base trading part on a little system that is running the whole time (like a Raspberry Pi). On your main workstation you can install the full software such that you can use the evaluation interface. To install just the base package system wide, run this: sudo python3 -m pip install vigilant-crypto-snatch If you are not running on a Raspberry Pi with 32 bit Linux, you can also install the evaluation interface and/or the GUI with the following square bracket syntax, where you can either include evaluation , gui or evaluation,gui . sudo python3 -m pip install 'vigilant-crypto-snatch[evaluation,gui]' If you don't want to install it system-wide, you can instead use python3 -p pip install --user vigilant . In that case you have to make sure that ~/.local/bin is part of your PATH environment variable. Once you are done with the installation, go over to the configuration .","title":"Installation"},{"location":"installation/general/#virtualenv","text":"Maybe you want to install the software and all its dependencies into a virtual environment. For this first create a virtual environment: $ virtualenv /tmp/vigilant-crypto-snatch-5-2-0 created virtual environment CPython3.10.1.final.0-64 in 485ms Choose a directory that makes sense for you, like ~/.local/share/virtualenvs/vigilant-crypto-snatch . Then activate the virtual environment: $ source /tmo/vigilant-crypto-snatch-5-2-0/bin/activate And now you can install it via pip, as usual: $ pip install --upgrade vigilant-crypto-snatch Whenever you want to use it, you will first need to activate the environment and then you can just call vigilant-crypto-snatch .","title":"Virtualenv"},{"location":"installation/general/#upgrades","text":"If you want to upgrade use: sudo python3 -m pip install vigilant-crypto-snatch --upgrade In case you have installed it differently, you will likely also need to upgrade in the same way. We sometimes update the configuration options a bit and don't offer an automated migration path. You will likely get some errors on startup. Please consult the documentation to see how configuration works with the current version.","title":"Upgrades"},{"location":"installation/windows/","text":"Installation on Windows If you want to use the program on Windows, you will first have to install Python. Installing Python Go to the Python website : Then download the Windows Installer for 64-Bit: Launch the installer, and add Python to the PATH. This will make it easier later on. Then just press \u201cInstall Now\u201d. After the setup has gone through, it will allow you to extend the command line limit. This might be necessary, I would just do that. Then you are finished and have Python installed on your system. Installing the program Then open a command line by pressing Windows and type \u201ccmd\u201d to launch the command line. You will see a window like this: Then type pip install vigilant-crypto-snatch and press Enter . It will start to download the latest version of the program: Eventually it will finish and show you the command line again: You should be able to start vigilant-crypto-snatch without arguments by typing that now: If you get this help screen, then everything is installed correctly. Creating the config file Next you will need to go through the configuration. We first need to create the directory for that. Open the Explorer and navigate to your user directory: Then click into the address bar such that you can change the path. Append an AppData to it, like this: After pressing Enter , you will see Local , LocalLow and Roaming . Double-click on Roaming . Then you should find various directories from applications that you use. Create a new directory Martin Ueding and then inside that create another called vigilant-crypto-snatch . Go into that directory: Then right-click to create a new \u201ctext file\u201d called config.yml . You can edit that configuration file using the \u201cNotepad\u201d editor from Windows. Alternatively you can download a programmer's editor like Atom or Notepad++ . Fill in the configuration as described in the configuration documentation . After adding all the configuration, this is how the test-drive will look like:","title":"Installation on Windows"},{"location":"installation/windows/#installation-on-windows","text":"If you want to use the program on Windows, you will first have to install Python.","title":"Installation on Windows"},{"location":"installation/windows/#installing-python","text":"Go to the Python website : Then download the Windows Installer for 64-Bit: Launch the installer, and add Python to the PATH. This will make it easier later on. Then just press \u201cInstall Now\u201d. After the setup has gone through, it will allow you to extend the command line limit. This might be necessary, I would just do that. Then you are finished and have Python installed on your system.","title":"Installing Python"},{"location":"installation/windows/#installing-the-program","text":"Then open a command line by pressing Windows and type \u201ccmd\u201d to launch the command line. You will see a window like this: Then type pip install vigilant-crypto-snatch and press Enter . It will start to download the latest version of the program: Eventually it will finish and show you the command line again: You should be able to start vigilant-crypto-snatch without arguments by typing that now: If you get this help screen, then everything is installed correctly.","title":"Installing the program"},{"location":"installation/windows/#creating-the-config-file","text":"Next you will need to go through the configuration. We first need to create the directory for that. Open the Explorer and navigate to your user directory: Then click into the address bar such that you can change the path. Append an AppData to it, like this: After pressing Enter , you will see Local , LocalLow and Roaming . Double-click on Roaming . Then you should find various directories from applications that you use. Create a new directory Martin Ueding and then inside that create another called vigilant-crypto-snatch . Go into that directory: Then right-click to create a new \u201ctext file\u201d called config.yml . You can edit that configuration file using the \u201cNotepad\u201d editor from Windows. Alternatively you can download a programmer's editor like Atom or Notepad++ . Fill in the configuration as described in the configuration documentation . After adding all the configuration, this is how the test-drive will look like:","title":"Creating the config file"},{"location":"usage/evaluate/","text":"Subcommand evaluate It is not inherently clear how triggers should be set. There are multiple variables that have to be tuned for each trigger: Time delay Cooloff Drop percentage Fiat volume We can try to verify a given strategy using historical data. We can also use the historical data to get an idea of a good strategy. Then we just simulate the given triggers and see how they perform. We provide a fun experimentation interface which is built with Streamlit and runs directly in your browser. This interface can be used online using the hosted version . Alternatively it can be started locally using the evaluate subcommand without any additional parameters: vigilant-crypto-snatch evaluate You can then select a crypto and a fiat currency to use for the analysis. Then you can just switch between the various tools that are offered. These are described below. Possible errors It might be possible that you cannot start the Streamlit interface. The most basic error could be an ImportError saying that the package altair or streamlit could not be imported. In that case you haven't installed the evaluation extra. See the installation instructions on the front page. While starting it, you might get an error about too many files connected via inotify. In this case you need to create a file at .streamlit/config.toml and give it this content: [server] fileWatcherType = \"none\" Price tool Here you can just see the prices that we got from the historical API. This is nothing special, just a plot. These plots are slightly interactive, so you can make them fullscreen and they will render with higher quality. Trigger simulation tool You simulate triggers on historical data. You can limit the evaluation data to a given range. Unfortunately Streamlit doesn't support a range slider yet, so the numbers don't make so much sense. The actual date is shown right below and will be updated as you move the slider. You can simulate as many triggers as you like. Set the number that you want and then just select the type of trigger and tune the parameters to your liking. It will give you a summary table looks like this: You can make this table full screen and also sort by any column. Just click on a column header and it will sort. You will also get a plot which shows the amount of money you have invested as well as the value of the crypto assets aquired. With this you can get a sense on the gains. The plot is interactive, you can pan and zoom with the mouse. You also have a table with the trades that were performed. In case the trigger has not been executed once, you will of course get a message. Drop survey tool Fiddling with individual triggers can be informative, but a more meta view could be very helpful. For this all sorts of drop triggers are performed, with a grid of various delays and various drop percentages. You can control the ranges of both with two-way sliders. Each time such a trigger is executed a fixed unit of fiat currency is invested. At the end of the time period the amount of crypto currency is normalized by the amount of fiat currency spent. This will show the most efficient triggers. It doesn't show how often these triggers have been used, or how much crypto currency you will have in the end. In the resulting heat map you can see colored areas where the most gains are in a dark red. In regions where the trigger has never been executed, you will just see black. These regions indicate that there was no such drop in the period looked at. Likely there will be one really dark area. This is an artefact from a single large drop in the past three months. Of course this is the best drop trigger for that particluar period, but it does not really generalize. So be wary that different historical periods look differently. Use this plot to get a general sense of fluctuations in the market and which triggers would fire often and form a good base strategy. In the above image, having a trigger at around 10 % and 24 hours delay seems to be a reasonable choice. You might still want to include some really ambitious triggers such that you can realize large gains. For instance having one for 25 % within 48 hours could be a good idea. Trade overview When you use the evaluation interface locally with your database, you can also see an overview over all the recorded trades from the software. There is one plot similar to the one shown by investment portfolio services. You can see the value of your bought coins and the spent fiat over time. The spent money is with the solid line, the value of your coins in the solid area. The plot is only updated when there is another trade, it doesn't try to look up historical prices in between. Then there is an overview over the amount of fiat that was spent over the months: This can help you to keep your budget in check and potentially reduce the triggers a bit. Value with current price Then we have plots which are potentially confusing because they compare historic investments with the current price. This means that the plots will change whenever you look at them again. It makes it a bit hard to evaluate the strategy, but perhaps they can be useful still. One is with the gains from each trigger execution, compared to the current price: And also grouped by month: Depending on the current price, everything will be shift up or down. It will change historic benefits as well. Likely the first plot is the easiest to understand.","title":"Subcommand evaluate"},{"location":"usage/evaluate/#subcommand-evaluate","text":"It is not inherently clear how triggers should be set. There are multiple variables that have to be tuned for each trigger: Time delay Cooloff Drop percentage Fiat volume We can try to verify a given strategy using historical data. We can also use the historical data to get an idea of a good strategy. Then we just simulate the given triggers and see how they perform. We provide a fun experimentation interface which is built with Streamlit and runs directly in your browser. This interface can be used online using the hosted version . Alternatively it can be started locally using the evaluate subcommand without any additional parameters: vigilant-crypto-snatch evaluate You can then select a crypto and a fiat currency to use for the analysis. Then you can just switch between the various tools that are offered. These are described below.","title":"Subcommand evaluate"},{"location":"usage/evaluate/#possible-errors","text":"It might be possible that you cannot start the Streamlit interface. The most basic error could be an ImportError saying that the package altair or streamlit could not be imported. In that case you haven't installed the evaluation extra. See the installation instructions on the front page. While starting it, you might get an error about too many files connected via inotify. In this case you need to create a file at .streamlit/config.toml and give it this content: [server] fileWatcherType = \"none\"","title":"Possible errors"},{"location":"usage/evaluate/#price-tool","text":"Here you can just see the prices that we got from the historical API. This is nothing special, just a plot. These plots are slightly interactive, so you can make them fullscreen and they will render with higher quality.","title":"Price tool"},{"location":"usage/evaluate/#trigger-simulation-tool","text":"You simulate triggers on historical data. You can limit the evaluation data to a given range. Unfortunately Streamlit doesn't support a range slider yet, so the numbers don't make so much sense. The actual date is shown right below and will be updated as you move the slider. You can simulate as many triggers as you like. Set the number that you want and then just select the type of trigger and tune the parameters to your liking. It will give you a summary table looks like this: You can make this table full screen and also sort by any column. Just click on a column header and it will sort. You will also get a plot which shows the amount of money you have invested as well as the value of the crypto assets aquired. With this you can get a sense on the gains. The plot is interactive, you can pan and zoom with the mouse. You also have a table with the trades that were performed. In case the trigger has not been executed once, you will of course get a message.","title":"Trigger simulation tool"},{"location":"usage/evaluate/#drop-survey-tool","text":"Fiddling with individual triggers can be informative, but a more meta view could be very helpful. For this all sorts of drop triggers are performed, with a grid of various delays and various drop percentages. You can control the ranges of both with two-way sliders. Each time such a trigger is executed a fixed unit of fiat currency is invested. At the end of the time period the amount of crypto currency is normalized by the amount of fiat currency spent. This will show the most efficient triggers. It doesn't show how often these triggers have been used, or how much crypto currency you will have in the end. In the resulting heat map you can see colored areas where the most gains are in a dark red. In regions where the trigger has never been executed, you will just see black. These regions indicate that there was no such drop in the period looked at. Likely there will be one really dark area. This is an artefact from a single large drop in the past three months. Of course this is the best drop trigger for that particluar period, but it does not really generalize. So be wary that different historical periods look differently. Use this plot to get a general sense of fluctuations in the market and which triggers would fire often and form a good base strategy. In the above image, having a trigger at around 10 % and 24 hours delay seems to be a reasonable choice. You might still want to include some really ambitious triggers such that you can realize large gains. For instance having one for 25 % within 48 hours could be a good idea.","title":"Drop survey tool"},{"location":"usage/evaluate/#trade-overview","text":"When you use the evaluation interface locally with your database, you can also see an overview over all the recorded trades from the software. There is one plot similar to the one shown by investment portfolio services. You can see the value of your bought coins and the spent fiat over time. The spent money is with the solid line, the value of your coins in the solid area. The plot is only updated when there is another trade, it doesn't try to look up historical prices in between. Then there is an overview over the amount of fiat that was spent over the months: This can help you to keep your budget in check and potentially reduce the triggers a bit.","title":"Trade overview"},{"location":"usage/evaluate/#value-with-current-price","text":"Then we have plots which are potentially confusing because they compare historic investments with the current price. This means that the plots will change whenever you look at them again. It makes it a bit hard to evaluate the strategy, but perhaps they can be useful still. One is with the gains from each trigger execution, compared to the current price: And also grouped by month: Depending on the current price, everything will be shift up or down. It will change historic benefits as well. Likely the first plot is the easiest to understand.","title":"Value with current price"},{"location":"usage/general/","text":"General Usage This page is about invoking the program in an interactive or manual way. This is the right thing if you are just configuring it and want to test it. For production use, see the page about deployment . The program has a hierarchical command line interface with multiple subcommands. If you have installed it system-wide, you can just directly call it. Otherwise you might have to add ~/.local/bin to your PATH variable. With the --help option you will see an up-to-date list of options. The general structure of a call is this: vigilant-crypto-snatch [general options] subcommand [subcommand options] The general options are the following: --loglevel : The program can emit a lot of status output while running. You can specify a log level with --loglevel LEVEL , where LEVEL can be critical , error , warning , info or debug . The info level is the default and does not fill the terminal with tons of output. You can set it to debug if you want to have more output and want to diagnose your triggers. Take a look at the subcommands in the navigation sidebar. You likely want to start with the \u201ctest-drive\u201d to verify that your installation and configuration is correct. Then you may want to use the \u201cevaluate\u201d interface to find optimal triggers for your taste. And finally use \u201cwatch\u201d to start watching the market.","title":"General Usage"},{"location":"usage/general/#general-usage","text":"This page is about invoking the program in an interactive or manual way. This is the right thing if you are just configuring it and want to test it. For production use, see the page about deployment . The program has a hierarchical command line interface with multiple subcommands. If you have installed it system-wide, you can just directly call it. Otherwise you might have to add ~/.local/bin to your PATH variable. With the --help option you will see an up-to-date list of options. The general structure of a call is this: vigilant-crypto-snatch [general options] subcommand [subcommand options] The general options are the following: --loglevel : The program can emit a lot of status output while running. You can specify a log level with --loglevel LEVEL , where LEVEL can be critical , error , warning , info or debug . The info level is the default and does not fill the terminal with tons of output. You can set it to debug if you want to have more output and want to diagnose your triggers. Take a look at the subcommands in the navigation sidebar. You likely want to start with the \u201ctest-drive\u201d to verify that your installation and configuration is correct. Then you may want to use the \u201cevaluate\u201d interface to find optimal triggers for your taste. And finally use \u201cwatch\u201d to start watching the market.","title":"General Usage"},{"location":"usage/gui/","text":"Graphical User Interface Since version 5.7.0 we also have a graphical user interface written in Qt. It is still not fully featured and likely still full of little issues. Please use it with this in mind, and report bugs such that this can be improved. The GUI provides a configuration tab where you can configure all the necessary parts to run the program. The status screen is still rudimentary but should allow you to run the triggers and therefore have the same feature set as you have with the command line utility. To start the graphical user interface, run vigilant-crypto-snatch-qt from the command line. There is no desktop icon for it, yet.","title":"Graphical User Interface"},{"location":"usage/gui/#graphical-user-interface","text":"Since version 5.7.0 we also have a graphical user interface written in Qt. It is still not fully featured and likely still full of little issues. Please use it with this in mind, and report bugs such that this can be improved. The GUI provides a configuration tab where you can configure all the necessary parts to run the program. The status screen is still rudimentary but should allow you to run the triggers and therefore have the same feature set as you have with the command line utility. To start the graphical user interface, run vigilant-crypto-snatch-qt from the command line. There is no desktop icon for it, yet.","title":"Graphical User Interface"},{"location":"usage/test-drive/","text":"Subcommand test-drive In order to check your configuration, use the test-drive subcommand. It will test the following things: Can the database be loaded? Can we receive the balance from your marketplace? This verifies whether you have set up your private keys. Can we retrieve a historical price? Can your triggers be constructed? Can a message be sent via Telegram, if you have set it up? If that runs through, you have a working configuration.","title":"Subcommand test-drive"},{"location":"usage/test-drive/#subcommand-test-drive","text":"In order to check your configuration, use the test-drive subcommand. It will test the following things: Can the database be loaded? Can we receive the balance from your marketplace? This verifies whether you have set up your private keys. Can we retrieve a historical price? Can your triggers be constructed? Can a message be sent via Telegram, if you have set it up? If that runs through, you have a working configuration.","title":"Subcommand test-drive"},{"location":"usage/watch/","text":"Subcommand watch The main command is watch . It will monitor the market and place buy orders. When you want to quit, just press Ctrl + C . All historical price data and performed transactions will be stored in a SQLite database at ~/.local/share/vigilant-crypto-snatch/db.sqlite (elsewhere on Windows). We sometimes change the database format between major releases. In that case it is easiest to delete the database and let the script create the new one. As there are only so few users, we don't offer proper database migrations. An example for running the script with log level \u201cinfo\u201d: vigilant-crypto-snatch --loglevel info watch Nonce rejections with Kraken If you happen to get nonce errors with the Kraken marketplace, consider using less triggers for it, or modifying your API key according to their guide .","title":"Subcommand watch"},{"location":"usage/watch/#subcommand-watch","text":"The main command is watch . It will monitor the market and place buy orders. When you want to quit, just press Ctrl + C . All historical price data and performed transactions will be stored in a SQLite database at ~/.local/share/vigilant-crypto-snatch/db.sqlite (elsewhere on Windows). We sometimes change the database format between major releases. In that case it is easiest to delete the database and let the script create the new one. As there are only so few users, we don't offer proper database migrations. An example for running the script with log level \u201cinfo\u201d: vigilant-crypto-snatch --loglevel info watch","title":"Subcommand watch"},{"location":"usage/watch/#nonce-rejections-with-kraken","text":"If you happen to get nonce errors with the Kraken marketplace, consider using less triggers for it, or modifying your API key according to their guide .","title":"Nonce rejections with Kraken"}]}